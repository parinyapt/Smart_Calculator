"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const decimal_js_1 = require("decimal.js");
exports.Decimal = decimal_js_1.Decimal;
const functions_1 = require("./default/functions");
const units_1 = require("./default/units");
const constants_1 = require("./evaluator/constants");
const converter_1 = require("./evaluator/converter");
const environment_1 = require("./evaluator/environment");
exports.Environment = environment_1.Environment;
const evaluator_1 = require("./evaluator/evaluator");
const function_1 = require("./evaluator/function");
exports.FcalFunction = function_1.FcalFunction;
const scale_1 = require("./evaluator/scale");
const symboltable_1 = require("./evaluator/symboltable");
const JSONParser_1 = require("./json/JSONParser");
const token_1 = require("./parser/lex/token");
const datatype_1 = require("./types/datatype");
exports.Type = datatype_1.Type;
const phrase_1 = require("./types/phrase");
const units_2 = require("./types/units");
exports.Unit = units_2.Unit;
const lex_1 = require("./parser/lex/lex");
/**
 * Math expression evaluator.
 * It evaluates various arithmetic operations, percentage operations,
 * variables and functions with units
 */
class Fcal {
    constructor() {
        this.lst = new symboltable_1.SymbolTable(Fcal.gst);
        this.strict = false;
        this.environment = new environment_1.Environment(Fcal.functions, this.lst, Fcal.constants);
    }
    /**
     * Quick math expression evaluator
     * @param {string} source expression
     * @returns {Type} result
     */
    static eval(source) {
        return new Fcal().evaluate(source);
    }
    /**
     * register new fcal Functions
     * @param {Array<FcalFunction | Object>} functions list of fcal function definitions
     */
    static UseFunctions(functions) {
        for (const func of functions) {
            this.UseFunction(func);
        }
    }
    /**
     * Register new Fcal function
     * @param {FcalFunction | Object} function fcal function definitions
     */
    static UseFunction(func) {
        Fcal.gst.set(func.name, symboltable_1.Entity.FUNCTION);
        if (func instanceof function_1.FcalFunction) {
            this.functions.push(func);
            return;
        }
        this.functions.push(new function_1.FcalFunction(func.name, func.arity, func.func));
    }
    /**
     * Register new units
     * @param {Array<Unit | Object>} units
     */
    static UseUnits(units) {
        for (const unit of units) {
            this.UseUnit(unit);
        }
    }
    /**
     * Register new unit
     * @param {Unit | Object} unit
     */
    static UseUnit(unit) {
        if (unit instanceof units_2.Unit) {
            return this.units.push(unit);
        }
        const u = new units_2.Unit(unit.id, unit.ratio, unit.type, unit.phrases);
        if (unit.bias) {
            u.setBias(unit.bias);
        }
        if (unit.plural) {
            u.Plural(unit.plural);
        }
        if (unit.singular) {
            u.Singular(unit.singular);
        }
        this.units.push(u);
    }
    /**
     * Get unit meta by its phrase
     * @param {string} unit phrase
     * @returns {UnitMeta | null}
     */
    static getUnit(unit) {
        return this.units.get(unit);
    }
    /**
     * useConstants set the constants in fcal
     * @param { { [index: string]: Type | Decimal | number | string } } constants
     */
    static useConstants(constants) {
        this.constants.use(constants);
    }
    /**
     * useScales register new scale in fcal
     * @param { { [index: string]: Type | Decimal | number | string } } scales
     */
    static useScales(scales) {
        this.scales.use(scales);
    }
    /**
     * Register new converter function
     * @param {string}id id of the converter function
     * @param {converterFuncFmt}f function
     */
    static useConverter(id, f) {
        this.converters.set(id, f);
    }
    /**
     * Get the units list
     * @returns {Unit.List} units
     */
    static getUnits() {
        return this.units;
    }
    /**
     * Get the constants
     * @returns {Constant} constants
     */
    static getConstants() {
        return this.constants;
    }
    /**
     * Get the functions
     * @returns {FcalFunction.List} functions
     */
    static getFunctions() {
        return this.functions;
    }
    /**
     * Get the scales
     * @returns {Scale} scales
     */
    static getScales() {
        return this.scales;
    }
    /**
     * Get the converters
     * @returns {Converter} converters
     */
    static getConverters() {
        return this.converters;
    }
    /**
     * Scan the math expression and  gets array of tokens
     * @param {string} expression math expression
     * @returns {Token[]} array of tokens
     */
    static getTokensForExpression(expression) {
        const lexer = new lex_1.Lexer(expression, this.phrases, this.units, this.converters, this.scales);
        return lexer.getTokens();
    }
    static initialize() {
        if (!this.gst) {
            this.gst = new symboltable_1.SymbolTable();
        }
        if (!this.phrases) {
            this.phrases = this.getDefaultPhrases();
        }
        if (!this.units) {
            this.units = new units_2.Unit.List(Fcal.gst);
            this.setDefaultUnits();
        }
        if (!this.functions) {
            this.functions = new function_1.FcalFunction.List();
            this.setDefaultFunctions();
        }
        if (!this.constants) {
            this.constants = new constants_1.Constant(this.gst);
            this.setDefaultConstants();
        }
        if (!this.converters) {
            this.converters = new converter_1.Converter(this.gst);
            this.setDefaultConverter();
        }
        if (!this.scales) {
            this.scales = new scale_1.Scale(this.gst);
            this.setDefaultScales();
        }
    }
    static getDefaultPhrases() {
        const phrases = new phrase_1.Phrases(this.gst);
        phrases.push(token_1.TT.PLUS, ['PLUS', 'WITH', 'ADD']);
        phrases.push(token_1.TT.MINUS, ['MINUS', 'SUBTRACT', 'WITHOUT']);
        phrases.push(token_1.TT.TIMES, ['TIMES', 'MULTIPLIEDBY', 'mul']);
        phrases.push(token_1.TT.SLASH, ['DIVIDE', 'DIVIDEBY']);
        phrases.push(token_1.TT.CAP, ['POW']);
        phrases.push(token_1.TT.MOD, ['mod']);
        phrases.push(token_1.TT.OF, ['of']);
        phrases.push(token_1.TT.IN, ['in', 'as', 'to']);
        phrases.push(token_1.TT.AND, ['and']);
        phrases.push(token_1.TT.OR, ['or']);
        phrases.push(token_1.TT.NOT, ['not']);
        return phrases;
    }
    static setDefaultFunctions() {
        this.UseFunctions(functions_1.getDefaultFunctions());
    }
    static setDefaultUnits() {
        this.UseUnits(units_1.getDefaultUnits());
    }
    static setDefaultConstants() {
        this.useConstants({
            E: datatype_1.Type.BNumber.New('2.718281828459045235360287'),
            PI: datatype_1.Type.BNumber.New('3.141592653589793238462645'),
            PI2: datatype_1.Type.BNumber.New('6.2831853071795864769'),
            false: datatype_1.Type.FcalBoolean.FALSE,
            true: datatype_1.Type.FcalBoolean.TRUE,
        });
    }
    static setDefaultScales() {
        const thousand = 1000;
        const million = 1000000;
        const billion = 10000000;
        this.useScales({ k: thousand, M: million, B: billion, thousand, million, billion });
    }
    static setDefaultConverter() {
        const num = (v) => {
            return datatype_1.Type.BNumber.New(v.n);
        };
        const per = (v) => {
            return datatype_1.Type.Percentage.New(v.n);
        };
        this.useConverter('number', num);
        this.useConverter('num', num);
        this.useConverter('percentage', per);
        this.useConverter('percent', per);
    }
    /**
     * Evaluates given expression
     * it appends new line character if not present
     * @param {string} expression Math expression
     * @returns {Type} result of expression
     */
    evaluate(source) {
        source = prefixNewLIne(source);
        return this.rawEvaluate(source);
    }
    /**
     * rawEvaluates given expression
     * it does not appends new line character if not present
     * @param {string} expression Math expression
     * @returns {Type} result of expression
     */
    rawEvaluate(source) {
        return new evaluator_1.Evaluator(source /*expression */, Fcal.phrases, Fcal.units, this.environment, Fcal.converters, Fcal.scales, this.strict).evaluateExpression();
    }
    /**
     * Create new expression with copy of Fcal.Environment
     * @param {string} source Math  expression
     * @returns {Expression} Expression with parsed AST
     */
    expression(source) {
        // Cloning fcal session
        const symbolTable = new symboltable_1.SymbolTable(this.lst);
        // Creating new environment
        const env = new environment_1.Environment(Fcal.functions, symbolTable, Fcal.constants);
        // coping values from fcal
        env.values = new Map(this.environment.values);
        source = prefixNewLIne(source);
        return new Expression(new evaluator_1.Evaluator(source /* expression */, Fcal.phrases, Fcal.units, env /* environment */, Fcal.converters /* converters */, Fcal.scales, this.strict));
    }
    /**
     * Create new  Expression in sync with Fcal.Environment
     * @param {string} source Math expression
     * @returns {Expression} Expression with parsed AST
     */
    expressionSync(source) {
        source = prefixNewLIne(source);
        return new Expression(new evaluator_1.Evaluator(source /* expression */, Fcal.phrases /* environment */, Fcal.units, this.environment, Fcal.converters /* converters */, Fcal.scales, this.strict));
    }
    /**
     * create a new variable with value or assign value to variable
     * @param {Object | EnvInputType} values variables
     */
    setValues(values) {
        this.environment.use(values);
    }
    /**
     * Get the environment of this fcal session
     * @returns {Environment} env
     */
    getEnvironment() {
        return this.environment;
    }
    /**
     * Import expression from JSON
     * @param {string} source json
     * @returns {Expression}
     */
    fromJSON(source) {
        const parser = new JSONParser_1.JSONParser(source, Fcal.units, Fcal.converters);
        const symbolTable = new symboltable_1.SymbolTable(this.lst);
        const env = new environment_1.Environment(Fcal.functions, symbolTable, Fcal.constants);
        env.values = new Map(this.environment.values);
        source = prefixNewLIne(source);
        return new Expression(new evaluator_1.Evaluator(parser.parse(), Fcal.phrases, Fcal.units, env, Fcal.converters, Fcal.scales, this.strict));
    }
    /**
     * Set strict mode
     * @param v
     */
    setStrict(v) {
        this.strict = v;
    }
}
exports.Fcal = Fcal;
function prefixNewLIne(source) {
    if (source.endsWith('\n')) {
        return source;
    }
    return source + '\n';
}
/**
 * Expression takes AST created from Parser and
 * evaluate AST with its state
 */
class Expression {
    constructor(evaluator) {
        this.evaluator = evaluator;
    }
    /**
     * Evaluate AST of Math expression
     * @returns {Type}  result of Math expression
     */
    evaluate() {
        return this.evaluator.evaluateExpression();
    }
    /**
     * Change state of variables
     * if variable is not found,  it will create a new variable
     * @param {Object | Map} values variables
     */
    setValues(values) {
        this.evaluator.environment.use(values);
    }
    /**
     * Get the environment of this expression
     * @returns {Environment} environment
     */
    getValues() {
        return this.evaluator.environment;
    }
    /**
     * Get the AST tree view of the formula expression
     * @returns {string}  AST tree view
     */
    getAST() {
        return this.evaluator.getAST();
    }
    /**
     * Convert the expression into JSON
     * @returns {string} JSON
     */
    toJSON() {
        return this.evaluator.toJSON();
    }
    /**
     * Convert the expression into an Object
     */
    toObj() {
        return this.evaluator.toObj();
    }
    /**
     * Get scanned tokens
     * @returns {Token[] | undefined} tokens
     */
    getScannedTokens() {
        return this.evaluator.getScannedTokens();
    }
    toString() {
        return this.getAST();
    }
}
exports.Expression = Expression;
/**
 * FcalError represents Error in Fcal
 */
class FcalError extends Error {
    constructor(message, start, end) {
        super(message);
        this.start = start;
        this.end = end;
        this.message = message;
        if (!start) {
            this.name = 'FcalError';
            return;
        }
        if (!end) {
            this.end = start;
        }
        this.name = `FcalError [${this.start}, ${this.end}]`;
    }
    static mark(start, end) {
        return '^'.repeat(start === end ? 1 : end - start).padStart(end, '.');
    }
    /**
     * info gets more information about FcalError
     */
    info() {
        const values = Array();
        values.push(`err: ${this.message}\n`);
        if (this.source !== undefined && this.start !== undefined && this.end !== undefined) {
            values.push(`| ${this.source}`);
            values.push(`| ${FcalError.mark(this.start, this.end)}\n`);
        }
        return values.join('');
    }
}
exports.FcalError = FcalError;
/***************************************************************/
Fcal.initialize();
