"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fcal_1 = require("../fcal");
const expr_1 = require("../parser/expr");
const datatype_1 = require("../types/datatype");
const numberSystem_1 = require("../types/numberSystem");
const toJSON_1 = require("./toJSON");
class JSONParser {
    constructor(astJSON, units, c) {
        this.units = units;
        this.c = c;
        this.ast = JSON.parse(astJSON);
    }
    parse() {
        return this.createExpr(this.ast);
    }
    createExpr(ast) {
        const type = ast.type;
        switch (type) {
            case toJSON_1.JSON_TYPES.BINARY:
                if (ast.right && ast.left && ast.operator) {
                    const left = this.createExpr(ast.left);
                    const right = this.createExpr(ast.right);
                    return new expr_1.Expr.Binary(left, ast.operator, right, ast.start, ast.end);
                }
                break;
            case toJSON_1.JSON_TYPES.GROUP:
                if (ast.value && typeof ast.value !== 'string') {
                    const expr = this.createExpr(ast.value);
                    return new expr_1.Expr.Grouping(expr, ast.start, ast.end);
                }
                break;
            case toJSON_1.JSON_TYPES.LITERAL:
                if (ast.value && typeof ast.value === 'string') {
                    return new expr_1.Expr.Literal(new datatype_1.Type.BNumber(ast.value), ast.start, ast.end);
                }
                break;
            case toJSON_1.JSON_TYPES.UNARY:
                if (ast.operator && ast.value && typeof ast.value !== 'string') {
                    const expr = this.createExpr(ast.value);
                    return new expr_1.Expr.Unary(ast.operator, expr, ast.start, ast.end);
                }
                break;
            case toJSON_1.JSON_TYPES.PERCENTAGE:
                if (ast.value && typeof ast.value !== 'string') {
                    const expr = this.createExpr(ast.value);
                    return new expr_1.Expr.Percentage(expr, ast.start, ast.end);
                }
                break;
            case toJSON_1.JSON_TYPES.UNIT:
                if (ast.phrase && ast.value && typeof ast.value !== 'string') {
                    const unitMeta = this.units.get(ast.phrase);
                    if (unitMeta) {
                        const expr = this.createExpr(ast.value);
                        return new expr_1.Expr.UnitExpr(expr, ast.phrase, unitMeta, ast.start, ast.end);
                    }
                }
                break;
            case toJSON_1.JSON_TYPES.CONVERSION:
                if (ast.value && typeof ast.value !== 'string') {
                    const value = this.createExpr(ast.value);
                    if (ast.unit) {
                        const unitMeta = this.units.get(ast.unit);
                        if (unitMeta) {
                            return new expr_1.Expr.ConversionExpr(value, unitMeta, ast.unit, ast.start, ast.end);
                        }
                    }
                    if (ast.ns) {
                        const ns = numberSystem_1.NumberSystem.get(ast.ns);
                        if (ns) {
                            return new expr_1.Expr.ConversionExpr(value, ns, ast.ns, ast.start, ast.end);
                        }
                    }
                    if (ast.converter) {
                        const cov = this.c.get(ast.converter);
                        if (cov) {
                            return new expr_1.Expr.ConversionExpr(value, cov, ast.converter, ast.start, ast.end);
                        }
                    }
                }
                break;
            case toJSON_1.JSON_TYPES.ASSIGN:
                if (ast.value && typeof ast.value !== 'string') {
                    const value = this.createExpr(ast.value);
                    if (ast.variable) {
                        return new expr_1.Expr.Assign(ast.variable, value, ast.start, ast.end);
                    }
                }
                break;
            case toJSON_1.JSON_TYPES.VARIABLE:
                if (ast.name) {
                    return new expr_1.Expr.Variable(ast.name, ast.start, ast.end);
                }
                break;
            case toJSON_1.JSON_TYPES.CALL:
                if (ast.name) {
                    const exprs = Array();
                    if (ast.args) {
                        for (const arg of ast.args) {
                            exprs.push(this.createExpr(arg));
                        }
                        return new expr_1.Expr.Call(ast.name, exprs, ast.start, ast.end);
                    }
                }
                break;
            case toJSON_1.JSON_TYPES.LOGICAL:
                if (ast.right && ast.left && ast.operator) {
                    const left = this.createExpr(ast.left);
                    const right = this.createExpr(ast.right);
                    return new expr_1.Expr.Logical(left, ast.operator, right, ast.start, ast.end);
                }
                break;
            case toJSON_1.JSON_TYPES.TERNARY:
                if (ast.main && ast.trueExpr && ast.falseExpr) {
                    const main = this.createExpr(ast.main);
                    const trueExpr = this.createExpr(ast.trueExpr);
                    const falseExpr = this.createExpr(ast.falseExpr);
                    return new expr_1.Expr.Ternary(main, trueExpr, falseExpr, ast.start, ast.end);
                }
                break;
        }
        throw new fcal_1.FcalError(`Invalid JSON ${ast}`);
    }
}
exports.JSONParser = JSONParser;
