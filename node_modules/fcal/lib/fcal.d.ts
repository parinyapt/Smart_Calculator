import { Decimal } from 'decimal.js';
import { Constant } from './evaluator/constants';
import { Converter, converterFuncFmt } from './evaluator/converter';
import { EnvInputType, Environment } from './evaluator/environment';
import { Evaluator } from './evaluator/evaluator';
import { FcalFunction, IUseFunction } from './evaluator/function';
import { Scale } from './evaluator/scale';
import { Token } from './parser/lex/token';
import { Type } from './types/datatype';
import { IUseUnit, Unit, UnitMeta } from './types/units';
/**
 * Math expression evaluator.
 * It evaluates various arithmetic operations, percentage operations,
 * variables and functions with units
 */
declare class Fcal {
    /**
     * Quick math expression evaluator
     * @param {string} source expression
     * @returns {Type} result
     */
    static eval(source: string): Type;
    /**
     * register new fcal Functions
     * @param {Array<FcalFunction | Object>} functions list of fcal function definitions
     */
    static UseFunctions(functions: (FcalFunction | IUseFunction)[]): void;
    /**
     * Register new Fcal function
     * @param {FcalFunction | Object} function fcal function definitions
     */
    static UseFunction(func: FcalFunction | IUseFunction): void;
    /**
     * Register new units
     * @param {Array<Unit | Object>} units
     */
    static UseUnits(units: (Unit | IUseUnit)[]): void;
    /**
     * Register new unit
     * @param {Unit | Object} unit
     */
    static UseUnit(unit: Unit | IUseUnit): void;
    /**
     * Get unit meta by its phrase
     * @param {string} unit phrase
     * @returns {UnitMeta | null}
     */
    static getUnit(unit: string): UnitMeta | null;
    /**
     * useConstants set the constants in fcal
     * @param { { [index: string]: Type | Decimal | number | string } } constants
     */
    static useConstants(constants: EnvInputType): void;
    /**
     * useScales register new scale in fcal
     * @param { { [index: string]: Type | Decimal | number | string } } scales
     */
    static useScales(scales: EnvInputType): void;
    /**
     * Register new converter function
     * @param {string}id id of the converter function
     * @param {converterFuncFmt}f function
     */
    static useConverter(id: string, f: converterFuncFmt): void;
    /**
     * Get the units list
     * @returns {Unit.List} units
     */
    static getUnits(): Unit.List;
    /**
     * Get the constants
     * @returns {Constant} constants
     */
    static getConstants(): Constant;
    /**
     * Get the functions
     * @returns {FcalFunction.List} functions
     */
    static getFunctions(): FcalFunction.List;
    /**
     * Get the scales
     * @returns {Scale} scales
     */
    static getScales(): Scale;
    /**
     * Get the converters
     * @returns {Converter} converters
     */
    static getConverters(): Converter;
    /**
     * Scan the math expression and  gets array of tokens
     * @param {string} expression math expression
     * @returns {Token[]} array of tokens
     */
    static getTokensForExpression(expression: string): Token[];
    static initialize(): void;
    private static gst;
    private static units;
    private static functions;
    private static phrases;
    private static constants;
    private static converters;
    private static scales;
    private static getDefaultPhrases;
    private static setDefaultFunctions;
    private static setDefaultUnits;
    private static setDefaultConstants;
    private static setDefaultScales;
    private static setDefaultConverter;
    private environment;
    private lst;
    private strict;
    constructor();
    /**
     * Evaluates given expression
     * it appends new line character if not present
     * @param {string} expression Math expression
     * @returns {Type} result of expression
     */
    evaluate(source: string): Type;
    /**
     * rawEvaluates given expression
     * it does not appends new line character if not present
     * @param {string} expression Math expression
     * @returns {Type} result of expression
     */
    rawEvaluate(source: string): Type;
    /**
     * Create new expression with copy of Fcal.Environment
     * @param {string} source Math  expression
     * @returns {Expression} Expression with parsed AST
     */
    expression(source: string): Expression;
    /**
     * Create new  Expression in sync with Fcal.Environment
     * @param {string} source Math expression
     * @returns {Expression} Expression with parsed AST
     */
    expressionSync(source: string): Expression;
    /**
     * create a new variable with value or assign value to variable
     * @param {Object | EnvInputType} values variables
     */
    setValues(values: EnvInputType): void;
    /**
     * Get the environment of this fcal session
     * @returns {Environment} env
     */
    getEnvironment(): Environment;
    /**
     * Import expression from JSON
     * @param {string} source json
     * @returns {Expression}
     */
    fromJSON(source: string): Expression;
    /**
     * Set strict mode
     * @param v
     */
    setStrict(v: boolean): void;
}
/**
 * Expression takes AST created from Parser and
 * evaluate AST with its state
 */
declare class Expression {
    private readonly evaluator;
    constructor(evaluator: Evaluator);
    /**
     * Evaluate AST of Math expression
     * @returns {Type}  result of Math expression
     */
    evaluate(): Type;
    /**
     * Change state of variables
     * if variable is not found,  it will create a new variable
     * @param {Object | Map} values variables
     */
    setValues(values: EnvInputType): void;
    /**
     * Get the environment of this expression
     * @returns {Environment} environment
     */
    getValues(): Environment;
    /**
     * Get the AST tree view of the formula expression
     * @returns {string}  AST tree view
     */
    getAST(): string;
    /**
     * Convert the expression into JSON
     * @returns {string} JSON
     */
    toJSON(): string;
    /**
     * Convert the expression into an Object
     */
    toObj(): object;
    /**
     * Get scanned tokens
     * @returns {Token[] | undefined} tokens
     */
    getScannedTokens(): Token[] | undefined;
    toString(): string;
}
/**
 * FcalError represents Error in Fcal
 */
declare class FcalError extends Error {
    private static mark;
    source?: string;
    start?: number;
    end?: number;
    constructor(message: string, start?: number, end?: number);
    /**
     * info gets more information about FcalError
     */
    info(): string;
}
export { Fcal, FcalError, Expression, FcalFunction, Environment, Unit, Type, Decimal };
