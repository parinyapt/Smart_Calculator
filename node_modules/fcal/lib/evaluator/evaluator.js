"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fcal_1 = require("../fcal");
const toJSON_1 = require("../json/toJSON");
const token_1 = require("../parser/lex/token");
const parser_1 = require("../parser/parser");
const datatype_1 = require("../types/datatype");
const numberSystem_1 = require("../types/numberSystem");
const units_1 = require("../types/units");
class Evaluator {
    constructor(source, phrases, units, environment, c, scale, strict) {
        this.environment = environment;
        this.strict = strict;
        if (typeof source === 'string') {
            const parser = new parser_1.Parser(source, phrases, units, c, scale, environment.symbolTable);
            this.parser = parser;
            this.ast = parser.parse();
            this.source = source;
            return;
        }
        this.ast = source;
    }
    getAST() {
        return this.ast.toString();
    }
    toJSON() {
        return new toJSON_1.ToJSON(this.ast).toJSON();
    }
    toObj() {
        return new toJSON_1.ToJSON(this.ast).toObj();
    }
    getScannedTokens() {
        var _a;
        return (_a = this.parser) === null || _a === void 0 ? void 0 : _a.getScannedTokens();
    }
    visitCallExpr(expr) {
        const name = expr.name;
        let call;
        call = this.environment.functions.get(name);
        if (call) {
            if (call.arity !== -1) {
                if (call.arity !== expr.argument.length) {
                    throw new fcal_1.FcalError(`function ${name} expected ${call.arity} args but got ${expr.argument.length}`, expr.start, expr.end);
                }
            }
            const argument = Array();
            for (const param of expr.argument) {
                argument.push(this.evaluate(param));
            }
            return call.call(this.environment, argument);
        }
        throw new fcal_1.FcalError(`${name} is not callable`, expr.start, expr.end);
    }
    visitAssignExpr(expr) {
        const value = this.evaluate(expr.value);
        this.environment.set(expr.name, value);
        return value;
    }
    visitVariableExpr(expr) {
        return this.environment.get(expr.name, expr.start, expr.end);
    }
    evaluateExpression() {
        try {
            const value = this.evaluate(this.ast);
            this.environment.set('_', value);
            return value;
        }
        catch (e) {
            if (e instanceof fcal_1.FcalError) {
                e.source = this.source;
            }
            throw e;
        }
    }
    visitConversionExpr(expr) {
        const value = this.evaluate(expr.expression);
        if (value instanceof datatype_1.Type.Numeric) {
            if (expr.to instanceof units_1.UnitMeta) {
                return datatype_1.Type.UnitNumber.convertToUnit(value, expr.to).setSystem(value.ns);
            }
            if (expr.to instanceof numberSystem_1.NumberSystem) {
                return value.New(value.n).setSystem(expr.to);
            }
            return expr.to(value);
        }
        throw new fcal_1.FcalError('Expecting numeric value before in', expr.start, expr.end);
    }
    visitUnitExpr(expr) {
        const value = this.evaluate(expr.expression);
        if (value instanceof datatype_1.Type.Numeric) {
            return datatype_1.Type.UnitNumber.New(value.n, expr.unit).setSystem(value.ns);
        }
        throw new fcal_1.FcalError('Expecting numeric value before unit', expr.start, expr.end);
    }
    visitTernaryExpr(expr) {
        const main = this.evaluate(expr.main);
        if (main.trusty()) {
            return this.evaluate(expr.trueExpr);
        }
        return this.evaluate(expr.falseExpr);
    }
    visitLogicalExpr(expr) {
        const left = this.evaluate(expr.left);
        if (expr.operator.type === token_1.TT.AND) {
            return left.trusty() ? this.evaluate(expr.right) : left;
        }
        return left.trusty() ? left : this.evaluate(expr.right);
    }
    visitBinaryExpr(expr) {
        const left = this.evaluate(expr.left);
        const right = this.evaluate(expr.right);
        if (this.strict) {
            this.checkInvalidOperation(expr.operator.type, [left, right]);
        }
        switch (expr.operator.type) {
            case token_1.TT.EQUAL_EQUAL:
                return left.EQ(right);
            case token_1.TT.EQUAL_EQUAL_EQUAL:
                return new datatype_1.Type.FcalBoolean(left.n.eq(right.n));
            case token_1.TT.NOT_EQUAL:
                return left.NEQ(right);
            case token_1.TT.NOT_EQUAL_EQUAL:
                return new datatype_1.Type.FcalBoolean(!left.n.eq(right.n));
            case token_1.TT.GREATER:
                return left.GT(right);
            case token_1.TT.GREATER_EQUAL:
                return left.GTE(right);
            case token_1.TT.GREATER_EQUAL_EQUAL:
                return new datatype_1.Type.FcalBoolean(left.n.gte(right.n));
            case token_1.TT.LESS:
                return left.LT(right);
            case token_1.TT.LESS_EQUAL:
                return left.LTE(right);
            case token_1.TT.LESS_EQUAL_EQUAL:
                return new datatype_1.Type.FcalBoolean(left.n.lte(right.n));
            case token_1.TT.PLUS:
                return left.Add(right);
            case token_1.TT.MINUS:
                return left.Sub(right);
            case token_1.TT.TIMES:
                return left.times(right);
            case token_1.TT.FLOOR_DIVIDE:
                const v = left.divide(right);
                v.n = v.n.floor();
                return v;
            case token_1.TT.SLASH:
                return left.divide(right);
            case token_1.TT.MOD:
                return left.modulo(right);
            case token_1.TT.CAP:
                return left.power(right);
            case token_1.TT.OF:
                // check whether boolean involved in percentage operation
                if (left instanceof datatype_1.Type.FcalBoolean || right instanceof datatype_1.Type.FcalBoolean) {
                    throw new fcal_1.FcalError('Unexpected Boolean in percentage operation');
                }
                if ((left instanceof datatype_1.Type.BNumber && right instanceof datatype_1.Type.BNumber) ||
                    (left instanceof datatype_1.Type.Percentage && right instanceof datatype_1.Type.Percentage)) {
                    return new datatype_1.Type.Percentage(left.n.div(right.n).mul(100));
                }
                if (left instanceof datatype_1.Type.UnitNumber && right instanceof datatype_1.Type.UnitNumber) {
                    if (left.unit.id === right.unit.id) {
                        return new datatype_1.Type.Percentage(datatype_1.Type.UnitNumber.convertToUnit(left, right.unit)
                            .n.div(right.n)
                            .mul(100));
                    }
                    return new datatype_1.Type.Percentage(left.n.div(right.n).mul(100));
                }
                if (left instanceof datatype_1.Type.Percentage) {
                    const per = left;
                    return right.New(per.percentageValue(right.n));
                }
                throw new fcal_1.FcalError(`Expecting Percentage type in left side of percentage operation but got (${datatype_1.Type.typeVsStr[left.TYPE]}, ${datatype_1.Type.typeVsStr[right.TYPE]})`);
            default:
                return datatype_1.Type.BNumber.ZERO;
        }
    }
    visitGroupingExpr(expr) {
        return this.evaluate(expr.expression);
    }
    visitLiteralExpr(expr) {
        return expr.value;
    }
    visitUnaryExpr(expr) {
        const right = this.evaluate(expr.right);
        if (expr.operator.type === token_1.TT.MINUS) {
            return right.negated();
        }
        if (expr.operator.type === token_1.TT.NOT) {
            return right.not();
        }
        return right;
    }
    visitPercentageExpr(expr) {
        const value = this.evaluate(expr.expression);
        if (value instanceof datatype_1.Type.Numeric) {
            return datatype_1.Type.Percentage.New(value.n);
        }
        throw new fcal_1.FcalError('Expecting numeric value in percentage', expr.start, expr.end);
    }
    evaluate(expr) {
        const ast = expr.eval(this);
        return ast;
    }
    checkInvalidOperation(operation, values) {
        let checkValue;
        for (const value of values) {
            if (value instanceof datatype_1.Type.Percentage) {
                continue;
            }
            if (!checkValue) {
                checkValue = value;
                continue;
            }
            if (checkValue.TYPE !== value.TYPE) {
                switch (operation) {
                    case token_1.TT.TIMES:
                    case token_1.TT.SLASH:
                    case token_1.TT.FLOOR_DIVIDE:
                    case token_1.TT.MOD:
                    case token_1.TT.PERCENTAGE:
                    case token_1.TT.CAP:
                    case token_1.TT.LESS_EQUAL_EQUAL:
                    case token_1.TT.GREATER_EQUAL_EQUAL:
                    case token_1.TT.EQUAL_EQUAL_EQUAL:
                    case token_1.TT.NOT_EQUAL_EQUAL:
                        continue;
                    default:
                        throw new fcal_1.FcalError(`Unexpected '${operation}' operation between different types (${datatype_1.Type.typeVsStr[checkValue.TYPE]}, ${datatype_1.Type.typeVsStr[value.TYPE]})`);
                }
            }
            if (checkValue instanceof datatype_1.Type.UnitNumber && value instanceof datatype_1.Type.UnitNumber) {
                if (checkValue.unit.id !== value.unit.id) {
                    this.throwUnexpectedUnits(operation, checkValue.unit.id, value.unit.id);
                }
            }
        }
    }
    throwUnexpectedUnits(operation, leftID, rightID) {
        throw new fcal_1.FcalError(`Unexpected '${operation}' operation between different units (${leftID}, ${rightID})`);
    }
}
exports.Evaluator = Evaluator;
