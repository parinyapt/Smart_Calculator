"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fcal_1 = require("../fcal");
const astPrinter_1 = require("./astPrinter");
class Expr {
    constructor(start, end) {
        this.start = start;
        this.end = end;
    }
    toString() {
        const res = new astPrinter_1.ASTPrinter().print(this);
        return res.substring(0, res.length - 2);
    }
    eval(visitor) {
        try {
            return this.accept(visitor);
        }
        catch (e) {
            if (e instanceof fcal_1.FcalError) {
                if (e.start === undefined) {
                    e.start = this.start;
                }
                if (e.end === undefined) {
                    e.end = this.end;
                }
            }
            throw e;
        }
    }
}
exports.Expr = Expr;
(function (Expr) {
    class Binary extends Expr {
        constructor(left, operator, right, start, end) {
            super(start, end);
            this.left = left;
            this.operator = operator;
            this.right = right;
        }
        accept(visitor) {
            return visitor.visitBinaryExpr(this);
        }
    }
    Expr.Binary = Binary;
    class Ternary extends Expr {
        constructor(main, trueExpr, falseExpr, start, end) {
            super(start, end);
            this.main = main;
            this.trueExpr = trueExpr;
            this.falseExpr = falseExpr;
        }
        accept(visitor) {
            return visitor.visitTernaryExpr(this);
        }
    }
    Expr.Ternary = Ternary;
    class Logical extends Expr {
        constructor(left, operator, right, start, end) {
            super(start, end);
            this.left = left;
            this.operator = operator;
            this.right = right;
        }
        accept(visitor) {
            return visitor.visitLogicalExpr(this);
        }
    }
    Expr.Logical = Logical;
    class Grouping extends Expr {
        constructor(expression, start, end) {
            super(start, end);
            this.expression = expression;
        }
        accept(visitor) {
            return visitor.visitGroupingExpr(this);
        }
    }
    Expr.Grouping = Grouping;
    class Assign extends Expr {
        constructor(name, value, start, end) {
            super(start, end);
            this.name = name;
            this.value = value;
        }
        accept(visitor) {
            return visitor.visitAssignExpr(this);
        }
    }
    Expr.Assign = Assign;
    class Variable extends Expr {
        constructor(name, start, end) {
            super(start, end);
            this.name = name;
        }
        accept(visitor) {
            return visitor.visitVariableExpr(this);
        }
    }
    Expr.Variable = Variable;
    class Call extends Expr {
        constructor(name, argument, start, end) {
            super(start, end);
            this.name = name;
            this.argument = argument;
        }
        accept(visitor) {
            return visitor.visitCallExpr(this);
        }
    }
    Expr.Call = Call;
    class Literal extends Expr {
        constructor(value, start, end) {
            super(start, end);
            this.value = value;
        }
        accept(visitor) {
            return visitor.visitLiteralExpr(this);
        }
    }
    Expr.Literal = Literal;
    class Percentage extends Expr {
        constructor(expression, start, end) {
            super(start, end);
            this.expression = expression;
        }
        accept(visitor) {
            return visitor.visitPercentageExpr(this);
        }
    }
    Expr.Percentage = Percentage;
    class UnitExpr extends Expr {
        constructor(expression, phrase, unit, start, end) {
            super(start, end);
            this.unit = unit;
            this.phrase = phrase;
            this.expression = expression;
        }
        accept(visitor) {
            return visitor.visitUnitExpr(this);
        }
    }
    Expr.UnitExpr = UnitExpr;
    class ConversionExpr extends Expr {
        constructor(expression, to, name, start, end) {
            super(start, end);
            this.to = to;
            this.name = name;
            this.expression = expression;
        }
        accept(visitor) {
            return visitor.visitConversionExpr(this);
        }
    }
    Expr.ConversionExpr = ConversionExpr;
    class Unary extends Expr {
        constructor(operator, right, start, end) {
            super(start, end);
            this.operator = operator;
            this.right = right;
        }
        accept(visitor) {
            return visitor.visitUnaryExpr(this);
        }
    }
    Expr.Unary = Unary;
})(Expr || (Expr = {}));
exports.Expr = Expr;
