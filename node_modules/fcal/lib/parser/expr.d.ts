import { converterFuncFmt } from '../evaluator/converter';
import { Type } from '../types/datatype';
import { NumberSystem } from '../types/numberSystem';
import { UnitMeta } from '../types/units';
import { Token } from './lex/token';
declare abstract class Expr {
    start?: number;
    end?: number;
    constructor(start?: number, end?: number);
    toString(): string;
    eval<T>(visitor: Expr.IVisitor<T>): T;
    abstract accept<T>(visitor: Expr.IVisitor<T>): T;
}
declare namespace Expr {
    class Binary extends Expr {
        left: Expr;
        operator: Token;
        right: Expr;
        constructor(left: Expr, operator: Token, right: Expr, start?: number, end?: number);
        accept<T>(visitor: Expr.IVisitor<T>): T;
    }
    class Ternary extends Expr {
        main: Expr;
        trueExpr: Expr;
        falseExpr: Expr;
        constructor(main: Expr, trueExpr: Expr, falseExpr: Expr, start?: number, end?: number);
        accept<T>(visitor: Expr.IVisitor<T>): T;
    }
    class Logical extends Expr {
        left: Expr;
        operator: Token;
        right: Expr;
        constructor(left: Expr, operator: Token, right: Expr, start?: number, end?: number);
        accept<T>(visitor: Expr.IVisitor<T>): T;
    }
    class Grouping extends Expr {
        expression: Expr;
        constructor(expression: Expr, start?: number, end?: number);
        accept<T>(visitor: Expr.IVisitor<T>): T;
    }
    class Assign extends Expr {
        name: string;
        value: Expr;
        constructor(name: string, value: Expr, start?: number, end?: number);
        accept<T>(visitor: Expr.IVisitor<T>): T;
    }
    class Variable extends Expr {
        name: string;
        constructor(name: string, start?: number, end?: number);
        accept<T>(visitor: Expr.IVisitor<T>): T;
    }
    class Call extends Expr {
        name: string;
        argument: Expr[];
        constructor(name: string, argument: Expr[], start?: number, end?: number);
        accept<T>(visitor: Expr.IVisitor<T>): T;
    }
    class Literal extends Expr {
        value: Type;
        constructor(value: Type, start?: number, end?: number);
        accept<T>(visitor: Expr.IVisitor<T>): T;
    }
    class Percentage extends Expr {
        expression: Expr;
        constructor(expression: Expr, start?: number, end?: number);
        accept<T>(visitor: Expr.IVisitor<T>): T;
    }
    class UnitExpr extends Expr {
        phrase: string;
        expression: Expr;
        unit: UnitMeta;
        constructor(expression: Expr, phrase: string, unit: UnitMeta, start?: number, end?: number);
        accept<T>(visitor: Expr.IVisitor<T>): T;
    }
    class ConversionExpr extends Expr {
        expression: Expr;
        to: UnitMeta | NumberSystem | converterFuncFmt;
        name: string;
        constructor(expression: Expr, to: UnitMeta | NumberSystem | converterFuncFmt, name: string, start?: number, end?: number);
        accept<T>(visitor: Expr.IVisitor<T>): T;
    }
    class Unary extends Expr {
        operator: Token;
        right: Expr;
        constructor(operator: Token, right: Expr, start?: number, end?: number);
        accept<T>(visitor: Expr.IVisitor<T>): T;
    }
    interface IVisitor<T> {
        visitBinaryExpr(expr: Expr.Binary): T;
        visitGroupingExpr(expr: Expr.Grouping): T;
        visitLiteralExpr(expr: Expr.Literal): T;
        visitUnaryExpr(expr: Expr.Unary): T;
        visitPercentageExpr(expr: Expr.Percentage): T;
        visitUnitExpr(expr: Expr.UnitExpr): T;
        visitConversionExpr(expr: Expr.ConversionExpr): T;
        visitAssignExpr(expr: Expr.Assign): T;
        visitVariableExpr(expr: Expr.Variable): T;
        visitCallExpr(expr: Expr.Call): T;
        visitLogicalExpr(expr: Expr.Logical): T;
        visitTernaryExpr(expr: Expr.Ternary): T;
    }
}
export { Expr };
