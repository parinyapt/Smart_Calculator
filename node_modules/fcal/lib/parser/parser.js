"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fcal_1 = require("../fcal");
const numberSystem_1 = require("../types/numberSystem");
const expr_1 = require("./expr");
const lex_1 = require("./lex/lex");
const token_1 = require("./lex/token");
class Parser {
    constructor(source, phrases, units, cc, scale, symbolTable) {
        this.source = source;
        this.lexer = new lex_1.Lexer(this.source, phrases, units, cc, scale);
        this.n = 0;
        this.tokens = [];
        this.c = cc;
        this.scale = scale;
        this.symbolTable = symbolTable;
    }
    parse() {
        try {
            const expr = this.Stmt();
            return expr;
        }
        catch (E) {
            if (E instanceof fcal_1.FcalError) {
                E.source = this.source;
            }
            throw E;
        }
    }
    getScannedTokens() {
        return this.tokens;
    }
    Stmt() {
        const expr = this.assignment();
        if (this.match([token_1.TT.NEWLINE])) {
            return expr;
        }
        if (this.peek().type === token_1.TT.EOL) {
            throw new fcal_1.FcalError('Expecting EOL', this.peek().end);
        }
        throw new fcal_1.FcalError(`Unexpected token ${this.peek().lexeme}`, this.peek().start, this.peek().end);
    }
    expression() {
        return this.assignment();
    }
    assignment() {
        const expr = this.ternary();
        if (this.match([token_1.TT.EQUAL, token_1.TT.DOUBLE_COLON])) {
            const leftExpr = this.assignment();
            if (expr instanceof expr_1.Expr.Variable) {
                const name = expr.name;
                return new expr_1.Expr.Assign(name, leftExpr, expr.start, leftExpr.end);
            }
            throw new fcal_1.FcalError('Expecting variable in left side of assignment', expr.start, expr.end);
        }
        if (this.match([
            token_1.TT.PLUS_EQUAL,
            token_1.TT.MINUS_EQUAL,
            token_1.TT.MULTIPLY_EQUAL,
            token_1.TT.DIVIDE_EQUAL,
            token_1.TT.FLOOR_DIVIDE_EQUAL,
            token_1.TT.POWER_EQUAL,
        ])) {
            const operator = this.previous();
            const leftExpr = this.assignment();
            if (expr instanceof expr_1.Expr.Variable) {
                let tt;
                switch (operator.type) {
                    case token_1.TT.PLUS_EQUAL:
                        tt = token_1.TT.PLUS;
                        break;
                    case token_1.TT.MINUS_EQUAL:
                        tt = token_1.TT.MINUS;
                        break;
                    case token_1.TT.MULTIPLY_EQUAL:
                        tt = token_1.TT.TIMES;
                        break;
                    case token_1.TT.DIVIDE_EQUAL:
                        tt = token_1.TT.SLASH;
                        break;
                    case token_1.TT.FLOOR_DIVIDE_EQUAL:
                        tt = token_1.TT.FLOOR_DIVIDE;
                        break;
                    default:
                        tt = token_1.TT.CAP;
                        break;
                }
                return new expr_1.Expr.Assign(expr.name, new expr_1.Expr.Binary(expr, new token_1.Token(tt, operator.lexeme, operator.literal, operator.start, operator.start), leftExpr, expr.start, leftExpr.end));
            }
            throw new fcal_1.FcalError('Expecting variable in left side of assignment', expr.start, expr.end);
        }
        return expr;
    }
    ternary() {
        let expr = this.logical();
        if (this.match([token_1.TT.Q])) {
            const trueExpr = this.ternary();
            this.consume(token_1.TT.DOUBLE_COLON, `Expecting ':' in ternary operation but found ${this.peek().type === '\n' ? 'EOL' : this.peek().type}`);
            const falseExpr = this.ternary();
            expr = new expr_1.Expr.Ternary(expr, trueExpr, falseExpr, expr.start, falseExpr.end);
        }
        return expr;
    }
    logical() {
        let expr = this.equality();
        while (this.match([token_1.TT.OR, token_1.TT.AND])) {
            const operator = this.previous();
            const right = this.equality();
            expr = new expr_1.Expr.Logical(expr, operator, right, expr.start, right.end);
        }
        return expr;
    }
    equality() {
        let expr = this.comparison();
        while (this.match([token_1.TT.EQUAL_EQUAL, token_1.TT.EQUAL_EQUAL_EQUAL, token_1.TT.NOT_EQUAL, token_1.TT.NOT_EQUAL_EQUAL])) {
            const operator = this.previous();
            const right = this.comparison();
            expr = new expr_1.Expr.Binary(expr, operator, right, expr.start, right.end);
        }
        return expr;
    }
    comparison() {
        let expr = this.addition();
        while (this.match([token_1.TT.GREATER, token_1.TT.GREATER_EQUAL, token_1.TT.GREATER_EQUAL_EQUAL, token_1.TT.LESS, token_1.TT.LESS_EQUAL, token_1.TT.LESS_EQUAL_EQUAL])) {
            const operator = this.previous();
            const right = this.addition();
            expr = new expr_1.Expr.Binary(expr, operator, right, expr.start, right.end);
        }
        return expr;
    }
    addition() {
        let expr = this.multiply();
        while (this.match([token_1.TT.PLUS, token_1.TT.MINUS])) {
            const operator = this.previous();
            const right = this.multiply();
            expr = new expr_1.Expr.Binary(expr, operator, right, expr.start, right.end);
        }
        return expr;
    }
    multiply() {
        let expr = this.unitConvert();
        while (this.match([token_1.TT.TIMES, token_1.TT.SLASH, token_1.TT.MOD, token_1.TT.OF, token_1.TT.FLOOR_DIVIDE])) {
            const operator = this.previous();
            const right = this.unitConvert();
            expr = new expr_1.Expr.Binary(expr, operator, right, expr.start, right.end);
        }
        return expr;
    }
    unitConvert() {
        const expr = this.unary();
        if (this.match([token_1.TT.IN])) {
            if (this.match([token_1.TT.UNIT])) {
                const unit = this.previous();
                const unit2 = this.lexer.units.get(unit.lexeme);
                if (unit2) {
                    return new expr_1.Expr.ConversionExpr(expr, unit2, unit.lexeme, expr.start, unit.end);
                }
            }
            if (this.match([token_1.TT.NS])) {
                const token = this.previous();
                const ns = numberSystem_1.NumberSystem.get(token.lexeme);
                if (ns) {
                    return new expr_1.Expr.ConversionExpr(expr, ns, token.lexeme, expr.start, token.end);
                }
            }
            if (this.match([token_1.TT.CC])) {
                const token = this.previous();
                const c = this.c.get(token.lexeme);
                if (c) {
                    return new expr_1.Expr.ConversionExpr(expr, c, token.lexeme, expr.start, token.end);
                }
            }
            throw new fcal_1.FcalError('Expecting unit after in');
        }
        return expr;
    }
    unary() {
        if (this.match([token_1.TT.PLUS, token_1.TT.MINUS, token_1.TT.NOT])) {
            const operator = this.previous();
            const right = this.unary();
            return new expr_1.Expr.Unary(operator, right, operator.start, right.end);
        }
        return this.exponent();
    }
    exponent() {
        let expr = this.suffix();
        while (this.match([token_1.TT.CAP])) {
            const operator = this.previous();
            const right = this.unary();
            expr = new expr_1.Expr.Binary(expr, operator, right, expr.start, right.end);
        }
        return expr;
    }
    suffix() {
        const expr = this.call();
        if (this.match([token_1.TT.PERCENTAGE])) {
            const operator = this.previous();
            return new expr_1.Expr.Percentage(expr, expr.start, operator.end);
        }
        if (this.match([token_1.TT.UNIT])) {
            const unit = this.previous();
            let unit2;
            unit2 = this.lexer.units.get(unit.lexeme);
            if (unit2) {
                return new expr_1.Expr.UnitExpr(expr, unit.lexeme, unit2, expr.start, unit.end);
            }
        }
        return expr;
    }
    call() {
        const expr = this.term();
        if (this.match([token_1.TT.OPEN_PAREN])) {
            if (expr instanceof expr_1.Expr.Variable) {
                const argument = Array();
                if (this.peek().type !== token_1.TT.CLOSE_PAREN) {
                    do {
                        argument.push(this.expression());
                    } while (this.match([token_1.TT.COMMA]));
                }
                this.consume(token_1.TT.CLOSE_PAREN, "Expect ')' after the arguments");
                return new expr_1.Expr.Call(expr.name, argument, expr.start, this.previous().end);
            }
            throw new fcal_1.FcalError(`Not callable`, expr.start, this.previous().end);
        }
        return expr;
    }
    term() {
        if (this.match([token_1.TT.Number])) {
            const numToken = this.previous();
            const num = numToken.literal;
            if (this.match([token_1.TT.SCALE])) {
                const s = this.previous().literal;
                const scaleC = this.scale.get(s);
                if (s) {
                    num.n = num.n.mul(scaleC.n);
                    return new expr_1.Expr.Literal(num, numToken.start, this.previous().end);
                }
            }
            return new expr_1.Expr.Literal(num, numToken.start, numToken.end);
        }
        if (this.match([token_1.TT.OPEN_PAREN])) {
            const start = this.previous();
            const expr = this.expression();
            this.consume(token_1.TT.CLOSE_PAREN, `Expect ')' after expression but found ${this.peek().lexeme}`);
            return new expr_1.Expr.Grouping(expr, start.start, this.previous().end);
        }
        if (this.match([token_1.TT.NAME])) {
            return new expr_1.Expr.Variable(this.previous().lexeme, this.previous().start, this.previous().end);
        }
        const lexeme = this.peek().lexeme;
        const entity = this.symbolTable.get(lexeme);
        if (entity) {
            throw new fcal_1.FcalError(`Expect expression but found ${lexeme} [${entity.toLowerCase()}]`, this.peek().start, this.peek().end);
        }
        throw new fcal_1.FcalError(`Expect expression but found ${lexeme === '\n' ? 'EOL' : lexeme}`, this.peek().start, this.peek().end);
    }
    match(types) {
        for (const type of types) {
            if (this.check(type)) {
                this.incr();
                return true;
            }
        }
        return false;
    }
    consume(type, message) {
        if (this.check(type)) {
            this.incr();
            return;
        }
        throw new fcal_1.FcalError(message, this.peek().start, this.peek().end);
    }
    check(type) {
        if (this.isAtEnd()) {
            return false;
        }
        return this.peek().type === type;
    }
    isAtEnd() {
        const token = this.nextToken();
        return token.type === token_1.TT.EOL;
    }
    nextToken() {
        if (this.n < this.tokens.length) {
            return this.tokens[this.n];
        }
        return this.getToken();
    }
    getToken() {
        const token = this.lexer.Next();
        if (token.type !== token_1.TT.EOL) {
            this.tokens.push(token);
        }
        return token;
    }
    previous() {
        return this.tokens[this.n - 1];
    }
    peek() {
        return this.nextToken();
    }
    incr() {
        this.n++;
    }
}
exports.Parser = Parser;
