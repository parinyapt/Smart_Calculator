"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fcal_1 = require("../../fcal");
const datatype_1 = require("../../types/datatype");
const numberSystem_1 = require("../../types/numberSystem");
const token_1 = require("./token");
class Lexer {
    constructor(source, phrases, units, cc, scale) {
        // Removing the space around expression
        this.source = source.replace(/[ \t]+$/, '');
        this.start = 0;
        this.current = 0;
        this.tokens = Array();
        this.phrases = phrases;
        this.units = units;
        this.cc = cc;
        this.scale = scale;
    }
    static isDigit(char) {
        return char >= '0' && char <= '9';
    }
    static isAlpha(char) {
        return (!Lexer.isDigit(char) && !this.isSpace(char) && char !== '\0' && char !== '\n' && !Lexer.notAlpha.includes(char));
    }
    static isSpace(char) {
        return char === '\t' || char === ' ';
    }
    static isBinaryDigit(char) {
        return char === '0' || char === '1';
    }
    static isOctalDigit(char) {
        return char >= '0' && char <= '8';
    }
    static isHexDigit(char) {
        return (char >= '0' && char <= '9') || (char >= 'a' && char <= 'f') || (char >= 'A' && char <= 'F');
    }
    Next() {
        if (this.isAtEnd()) {
            return token_1.Token.EOL(this.current);
        }
        return this.scan();
    }
    getTokens() {
        const tokens = [];
        let token;
        while ((token = this.Next()).type !== token_1.TT.EOL) {
            tokens.push(token);
        }
        return tokens;
    }
    scan() {
        const char = this.space();
        switch (char) {
            case token_1.TT.PLUS:
                if (this.peek(0) === token_1.TT.EQUAL) {
                    this.eat();
                    return this.TT(token_1.TT.PLUS_EQUAL);
                }
                return this.TT(token_1.TT.PLUS);
            case token_1.TT.MINUS:
                if (this.peek(0) === token_1.TT.EQUAL) {
                    this.eat();
                    return this.TT(token_1.TT.MINUS_EQUAL);
                }
                return this.TT(token_1.TT.MINUS);
            case token_1.TT.TIMES:
                if (this.peek(0) === token_1.TT.EQUAL) {
                    this.eat();
                    return this.TT(token_1.TT.MULTIPLY_EQUAL);
                }
                if (this.peek(0) === token_1.TT.TIMES) {
                    this.eat();
                    if (this.peek(0) === token_1.TT.EQUAL) {
                        this.eat();
                        return this.TT(token_1.TT.POWER_EQUAL);
                    }
                    return this.TT(token_1.TT.CAP);
                }
                return this.TT(token_1.TT.TIMES);
            case token_1.TT.SLASH:
                if (this.peek(0) === token_1.TT.EQUAL) {
                    this.eat();
                    return this.TT(token_1.TT.DIVIDE_EQUAL);
                }
                if (this.peek(0) === token_1.TT.SLASH) {
                    this.eat();
                    if (this.peek(0) === token_1.TT.EQUAL) {
                        this.eat();
                        return this.TT(token_1.TT.FLOOR_DIVIDE_EQUAL);
                    }
                    return this.TT(token_1.TT.FLOOR_DIVIDE);
                }
                return this.TT(token_1.TT.SLASH);
            case token_1.TT.EQUAL:
                if (this.peek(0) === token_1.TT.EQUAL) {
                    this.eat();
                    if (this.peek(0) === token_1.TT.EQUAL) {
                        this.eat();
                        return this.TT(token_1.TT.EQUAL_EQUAL_EQUAL);
                    }
                    return this.TT(token_1.TT.EQUAL_EQUAL);
                }
                return this.TT(token_1.TT.EQUAL);
            case token_1.TT.NOT:
                if (this.peek(0) === token_1.TT.EQUAL) {
                    this.eat();
                    if (this.peek(0) === token_1.TT.EQUAL) {
                        this.eat();
                        return this.TT(token_1.TT.NOT_EQUAL_EQUAL);
                    }
                    return this.TT(token_1.TT.NOT_EQUAL);
                }
                return this.TT(token_1.TT.NOT);
            case token_1.TT.GREATER:
                if (this.peek(0) === token_1.TT.EQUAL) {
                    this.eat();
                    if (this.peek(0) === token_1.TT.EQUAL) {
                        this.eat();
                        return this.TT(token_1.TT.GREATER_EQUAL_EQUAL);
                    }
                    return this.TT(token_1.TT.GREATER_EQUAL);
                }
                return this.TT(token_1.TT.GREATER);
            case token_1.TT.LESS:
                if (this.peek(0) === token_1.TT.EQUAL) {
                    this.eat();
                    if (this.peek(0) === token_1.TT.EQUAL) {
                        this.eat();
                        return this.TT(token_1.TT.LESS_EQUAL_EQUAL);
                    }
                    return this.TT(token_1.TT.LESS_EQUAL);
                }
                return this.TT(token_1.TT.LESS);
            case '&':
                if (this.peek(0) === '&') {
                    this.eat();
                    return this.TT(token_1.TT.AND);
                }
                throw new fcal_1.FcalError('Unexpected character &', this.current);
            case '|':
                if (this.peek(0) === '|') {
                    this.eat();
                    return this.TT(token_1.TT.OR);
                }
                throw new fcal_1.FcalError('Unexpected character |', this.current);
            case token_1.TT.COMMA:
                return this.TT(token_1.TT.COMMA);
            case token_1.TT.DOUBLE_COLON:
                return this.TT(token_1.TT.DOUBLE_COLON);
            case token_1.TT.OPEN_PAREN:
                return this.TT(token_1.TT.OPEN_PAREN);
            case token_1.TT.CLOSE_PAREN:
                return this.TT(token_1.TT.CLOSE_PAREN);
            case token_1.TT.CAP:
                if (this.peek(0) === token_1.TT.EQUAL) {
                    this.eat();
                    return this.TT(token_1.TT.POWER_EQUAL);
                }
                return this.TT(token_1.TT.CAP);
            case token_1.TT.Q:
                return this.TT(token_1.TT.Q);
            case token_1.TT.PERCENTAGE:
                return this.TT(token_1.TT.PERCENTAGE);
            case token_1.TT.NEWLINE:
                return this.TT(token_1.TT.NEWLINE);
            default:
                if (Lexer.isDigit(char)) {
                    return this.number();
                }
                return this.string();
        }
    }
    isAtEnd() {
        return this.current >= this.source.length;
    }
    eat() {
        this.current++;
        return this.source.charAt(this.current - 1);
    }
    peek(n) {
        if (this.current + n >= this.source.length) {
            return '\0';
        }
        return this.source.charAt(this.current + n);
    }
    string() {
        while (Lexer.isAlpha(this.peek(0)) || Lexer.isDigit(this.peek(0))) {
            this.eat();
        }
        const text = this.lexeme();
        let type;
        if (text === 'Infinity') {
            return this.TTWithLiteral(token_1.TT.Number, new datatype_1.Type.BNumber(text));
        }
        type = this.phrases.get(text);
        if (type) {
            return this.TT(type);
        }
        const s = this.scale.get(text);
        if (s) {
            return this.TTWithLiteral(token_1.TT.SCALE, text);
        }
        const unit = this.units.get(text);
        if (unit) {
            return this.TTWithLiteral(token_1.TT.UNIT, text);
        }
        const ns = numberSystem_1.NumberSystem.get(text);
        if (ns) {
            return this.TTWithLiteral(token_1.TT.NS, text);
        }
        const cc = this.cc.get(text);
        if (cc) {
            return this.TTWithLiteral(token_1.TT.CC, text);
        }
        return this.TT(token_1.TT.NAME);
    }
    number() {
        if (this.previous() === '0' && (this.peek(0) === 'b' || this.peek(0) === 'B')) {
            this.eat();
            while (Lexer.isDigit(this.peek(0))) {
                if (!Lexer.isBinaryDigit(this.peek(0))) {
                    throw new fcal_1.FcalError(`Unexpected '${this.peek(0)}' in binary number`, this.current);
                }
                this.eat();
                if (this.peek(0) === '_' && Lexer.isBinaryDigit(this.peek(1))) {
                    this.eat();
                }
            }
            const value = new datatype_1.Type.BNumber(this.lexeme().replace(/_/g, ''));
            value.setSystem(numberSystem_1.NumberSystem.bin);
            return this.TTWithLiteral(token_1.TT.Number, value);
        }
        if (this.previous() === '0' && (this.peek(0) === 'o' || this.peek(0) === 'O')) {
            this.eat();
            while (Lexer.isDigit(this.peek(0))) {
                if (!Lexer.isOctalDigit(this.peek(0))) {
                    throw new fcal_1.FcalError(`Unexpected '${this.peek(0)}' in Octal number`, this.current);
                }
                this.eat();
                if (this.peek(0) === '_' && Lexer.isOctalDigit(this.peek(1))) {
                    this.eat();
                }
            }
            const value = new datatype_1.Type.BNumber(this.lexeme().replace(/_/g, ''));
            value.setSystem(numberSystem_1.NumberSystem.oct);
            return this.TTWithLiteral(token_1.TT.Number, value);
        }
        if (this.previous() === '0' && (this.peek(0) === 'x' || this.peek(0) === 'X')) {
            this.eat();
            if (!Lexer.isHexDigit(this.peek(0))) {
                throw new fcal_1.FcalError(`Unexpected '${this.peek(0)}' in Hexadecimal`, this.current);
            }
            while (Lexer.isHexDigit(this.peek(0))) {
                this.eat();
                if (this.peek(0) === '_' && Lexer.isHexDigit(this.peek(1))) {
                    this.eat();
                }
            }
            const value = new datatype_1.Type.BNumber(this.lexeme().replace(/_/g, ''));
            value.setSystem(numberSystem_1.NumberSystem.hex);
            return this.TTWithLiteral(token_1.TT.Number, value);
        }
        if (this.peek(0) === '_') {
            this.eat();
        }
        while (Lexer.isDigit(this.peek(0))) {
            this.eat();
            if (this.peek(0) === '_' && Lexer.isDigit(this.peek(1))) {
                this.eat();
            }
        }
        if (this.peek(0) === '.' && Lexer.isDigit(this.peek(1))) {
            this.eat();
            while (Lexer.isDigit(this.peek(0))) {
                this.eat();
                if (this.peek(0) === '_' && Lexer.isDigit(this.peek(1))) {
                    this.eat();
                }
            }
        }
        if (this.peek(0) === 'E' || this.peek(0) === 'e') {
            let c = this.peek(0);
            this.eat();
            if (this.peek(0) === '+' || this.peek(0) === '-') {
                c = this.peek(0);
                this.eat();
            }
            if (!Lexer.isDigit(this.peek(0))) {
                let peekValue = this.peek(0);
                if (peekValue === '\n') {
                    peekValue = 'EOL';
                }
                throw new fcal_1.FcalError(`Expecting number after ${c} but got '${peekValue}'`, this.start, this.current);
            }
            while (Lexer.isDigit(this.peek(0))) {
                this.eat();
                if (this.peek(0) === '_' && Lexer.isDigit(this.peek(1))) {
                    this.eat();
                }
            }
        }
        return this.TTWithLiteral(token_1.TT.Number, new datatype_1.Type.BNumber(this.lexeme().replace(/_/g, '')));
    }
    TT(type) {
        return this.TTWithLiteral(type, null);
    }
    TTWithLiteral(type, literal) {
        const token = new token_1.Token(type, this.lexeme(), literal, this.start, this.current);
        this.start = this.current;
        this.tokens.push(token);
        return token;
    }
    lexeme() {
        return this.source.substring(this.start, this.current);
    }
    space() {
        let char = this.eat();
        while (Lexer.isSpace(char)) {
            this.start = this.current;
            char = this.eat();
        }
        return char;
    }
    previous() {
        if (this.current > 0) {
            return this.source.charAt(this.current - 1);
        }
        return '\0';
    }
}
exports.Lexer = Lexer;
Lexer.notAlpha = [
    token_1.TT.PLUS,
    token_1.TT.MINUS,
    token_1.TT.TIMES,
    token_1.TT.SLASH,
    token_1.TT.OPEN_PAREN,
    token_1.TT.CLOSE_PAREN,
    token_1.TT.CAP,
    token_1.TT.PERCENTAGE,
    token_1.TT.EQUAL,
    token_1.TT.COMMA,
    token_1.TT.DOUBLE_COLON,
    token_1.TT.NEWLINE,
    '&',
    '|',
    token_1.TT.LESS,
    token_1.TT.GREATER,
    '!',
    token_1.TT.Q,
];
