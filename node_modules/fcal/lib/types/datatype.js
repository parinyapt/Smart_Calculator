"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const decimal_js_1 = require("decimal.js");
const fcal_1 = require("../fcal");
const numberSystem_1 = require("./numberSystem");
var DATATYPE;
(function (DATATYPE) {
    DATATYPE[DATATYPE["NUMBER"] = 0] = "NUMBER";
    DATATYPE[DATATYPE["UNIT"] = 1] = "UNIT";
    DATATYPE[DATATYPE["PERCENTAGE"] = 2] = "PERCENTAGE";
})(DATATYPE = exports.DATATYPE || (exports.DATATYPE = {}));
var TYPE_RANK;
(function (TYPE_RANK) {
    TYPE_RANK[TYPE_RANK["PERCENTAGE"] = 0] = "PERCENTAGE";
    TYPE_RANK[TYPE_RANK["NUMBER"] = 1] = "NUMBER";
    TYPE_RANK[TYPE_RANK["UNIT"] = 2] = "UNIT";
})(TYPE_RANK = exports.TYPE_RANK || (exports.TYPE_RANK = {}));
class Type {
    toString() {
        return this.print();
    }
}
exports.Type = Type;
Type.typeVsStr = { 0: 'number', 1: 'unit', 2: 'percentage' };
/**
 * Represents a type of variable or value
 */
(function (Type) {
    class Numeric extends Type {
        constructor(value) {
            super();
            if (value instanceof decimal_js_1.Decimal) {
                this.n = value;
            }
            else {
                this.n = new decimal_js_1.Decimal(value);
            }
            this.ns = numberSystem_1.NumberSystem.dec;
            this.lf = false;
        }
        setSystem(numberSys) {
            this.ns = numberSys;
            return this;
        }
        toNumericString() {
            return this.ns.to(this.n);
        }
        print() {
            return this.toNumericString();
        }
        GT(value) {
            this.lf = true;
            if (this.TYPE >= value.TYPE) {
                return this.gt(value);
            }
            return value.gt(this);
        }
        GTE(value) {
            this.lf = true;
            if (this.TYPE >= value.TYPE) {
                return this.gte(value);
            }
            return value.gte(this);
        }
        LT(value) {
            this.lf = true;
            if (this.TYPE >= value.TYPE) {
                return this.lt(value);
            }
            return value.lt(this);
        }
        LTE(value) {
            this.lf = true;
            if (this.TYPE >= value.TYPE) {
                return this.lte(value);
            }
            return value.lte(this);
        }
        EQ(value) {
            this.lf = true;
            if (this.TYPE >= value.TYPE) {
                return this.eq(value);
            }
            return value.eq(this);
        }
        NEQ(value) {
            this.lf = true;
            if (this.TYPE >= value.TYPE) {
                return this.nEq(value);
            }
            return value.nEq(this);
        }
        Add(value) {
            if (!this.n.isFinite() && !value.n.isFinite()) {
                if (!((this.n.isNegative() && value.n.isNegative()) || (this.n.isPositive() && value.n.isPositive()))) {
                    // console.log(left.number, right.number);
                    throw new fcal_1.FcalError('Subtraction between Infinity is indeterminate');
                }
            }
            // check type to see which datatype operation
            // if both type is same na right variable operation
            this.lf = true;
            if (this.TYPE >= value.TYPE) {
                // check type rank to see which will be the return type
                if (this.TYPE_RANK <= value.TYPE_RANK) {
                    return value.New(this.plus(value).n);
                }
                return this.plus(value);
            }
            if (value.TYPE_RANK >= this.TYPE_RANK) {
                return value.plus(this);
            }
            return this.New(value.plus(this).n);
        }
        Sub(value) {
            return this.Add(value.negated());
        }
        times(value) {
            // check type to see which datatype operation
            // if both type is same na right variable operation
            this.lf = true;
            if (this.TYPE >= value.TYPE) {
                // check type rank to see which will be the return type
                if (this.TYPE_RANK <= value.TYPE_RANK) {
                    return value.New(this.mul(value).n);
                }
                return this.mul(value);
            }
            if (value.TYPE_RANK >= this.TYPE_RANK) {
                return value.mul(this);
            }
            return this.New(value.mul(this).n);
        }
        divide(value) {
            if (!this.n.isFinite() && !value.n.isFinite()) {
                throw new fcal_1.FcalError('Division between Infinity is indeterminate');
            }
            // check type to see which datatype operation
            // if both type is same na right variable operation
            this.lf = true;
            if (this.TYPE >= value.TYPE) {
                // check type rank to see which will be the return type
                if (this.TYPE_RANK <= value.TYPE_RANK) {
                    if (this.TYPE_RANK === value.TYPE_RANK) {
                        return this.div(value);
                    }
                    return value.New(this.div(value).n);
                }
                return this.div(value);
            }
            if (value.TYPE_RANK >= this.TYPE_RANK) {
                return value.div(this);
            }
            return this.New(value.div(this).n);
        }
        power(value) {
            if (this.isNegative()) {
                if (!value.n.isInt()) {
                    throw new fcal_1.FcalError(`Pow of operation results in complex number and complex number is not supported yet`);
                }
            }
            // console.log(`CAP ${this.number.toString()} ${value.number.toString()}`);
            // check type to see which datatype operation
            // if both type is same na right variable operation
            this.lf = true;
            if (this.TYPE >= value.TYPE) {
                // check type rank to see which will be the return type
                if (this.TYPE_RANK <= value.TYPE_RANK) {
                    if (this.TYPE_RANK === value.TYPE_RANK) {
                        return this.New(this.pow(value).n);
                    }
                    return value.New(this.pow(value).n);
                }
                return this.pow(value);
            }
            if (value.TYPE_RANK >= this.TYPE_RANK) {
                return value.pow(this);
            }
            return this.New(value.pow(this).n);
        }
        modulo(value) {
            if (!this.n.isFinite()) {
                throw new fcal_1.FcalError('Modulus with Infinity is indeterminate');
            }
            if (value.isZero()) {
                return new Type.BNumber('Infinity');
            }
            // check type to see which datatype operation
            // if both type is same na right variable operation
            this.lf = true;
            if (this.TYPE >= value.TYPE) {
                // check type rank to see which will be the return type
                if (this.TYPE_RANK <= value.TYPE_RANK) {
                    if (this.TYPE_RANK === value.TYPE_RANK) {
                        return this.New(this.mod(value).n);
                    }
                    return value.New(this.mod(value).n);
                }
                return this.mod(value);
            }
            if (value.TYPE_RANK >= this.TYPE_RANK) {
                return value.mod(this);
            }
            return this.New(value.mod(this).n);
        }
        toNumber() {
            return this.n.toNumber();
        }
        trusty() {
            return !this.n.isZero();
        }
        not() {
            return new FcalBoolean(this.n).not();
        }
    }
    Type.Numeric = Numeric;
    /**
     * Basic Number type
     */
    class BNumber extends Numeric {
        constructor(value) {
            super(value);
            this.TYPE = DATATYPE.NUMBER;
            this.TYPE_RANK = TYPE_RANK.NUMBER;
        }
        static New(value) {
            return new BNumber(value);
        }
        gt(value) {
            return new FcalBoolean(this.n.gt(value.n));
        }
        gte(value) {
            return new FcalBoolean(this.n.gte(value.n));
        }
        lt(value) {
            return new FcalBoolean(this.n.lt(value.n));
        }
        lte(value) {
            return new FcalBoolean(this.n.lte(value.n));
        }
        eq(value) {
            return new FcalBoolean(this.n.eq(value.n));
        }
        nEq(value) {
            return this.eq(value).not();
        }
        isZero() {
            return this.n.isZero();
        }
        isNegative() {
            return this.n.isNegative();
        }
        negated() {
            return BNumber.New(this.n.negated());
        }
        div(value) {
            return BNumber.New(this.n.div(value.n));
        }
        pow(value) {
            return BNumber.New(this.n.pow(value.n));
        }
        mod(value) {
            return BNumber.New(this.n.modulo(value.n));
        }
        mul(value) {
            return BNumber.New(this.n.mul(value.n));
        }
        plus(value) {
            return BNumber.New(this.n.plus(value.n));
        }
        New(value) {
            return BNumber.New(value);
        }
    }
    BNumber.ZERO = BNumber.New(new decimal_js_1.Decimal(0));
    Type.BNumber = BNumber;
    /**
     * Percentage type
     */
    class Percentage extends Numeric {
        constructor(value) {
            super(value);
            this.TYPE = DATATYPE.PERCENTAGE;
            this.TYPE_RANK = TYPE_RANK.PERCENTAGE;
        }
        static New(value) {
            return new Percentage(value);
        }
        gt(value) {
            if (value.TYPE === DATATYPE.PERCENTAGE) {
                return new FcalBoolean(this.n.gt(value.n));
            }
            if (value.lf) {
                return new FcalBoolean(value.n.gt(this.percentageValue(value.n)));
            }
            return new FcalBoolean(this.percentageValue(value.n).gt(value.n));
        }
        gte(value) {
            if (value.TYPE === DATATYPE.PERCENTAGE) {
                return new FcalBoolean(this.n.gte(value.n));
            }
            if (value.lf) {
                return new FcalBoolean(value.n.gte(this.percentageValue(value.n)));
            }
            return new FcalBoolean(this.percentageValue(value.n).gte(value.n));
        }
        lt(value) {
            if (value.TYPE === DATATYPE.PERCENTAGE) {
                return new FcalBoolean(this.n.lt(value.n));
            }
            if (value.lf) {
                return new FcalBoolean(value.n.lt(this.percentageValue(value.n)));
            }
            return new FcalBoolean(this.percentageValue(value.n).lt(value.n));
        }
        lte(value) {
            if (value.TYPE === DATATYPE.PERCENTAGE) {
                return new FcalBoolean(this.n.lte(value.n));
            }
            if (value.lf) {
                return new FcalBoolean(value.n.lte(this.percentageValue(value.n)));
            }
            return new FcalBoolean(this.percentageValue(value.n).lte(value.n));
        }
        eq(value) {
            if (value.TYPE === DATATYPE.PERCENTAGE) {
                return new FcalBoolean(this.n.eq(value.n));
            }
            return new FcalBoolean(value.n.eq(this.percentageValue(value.n)));
        }
        nEq(value) {
            return this.eq(value).not();
        }
        isZero() {
            return this.n.isZero();
        }
        isNegative() {
            return this.n.isNegative();
        }
        negated() {
            return Percentage.New(this.n.negated());
        }
        plus(value) {
            if (value.TYPE === DATATYPE.PERCENTAGE) {
                return Percentage.New(this.n.plus(value.n));
            }
            return Percentage.New(value.n.plus(this.percentageValue(value.n)));
        }
        mul(value) {
            if (value.TYPE === DATATYPE.PERCENTAGE) {
                return Percentage.New(this.n.mul(value.n));
            }
            return Percentage.New(value.n.mul(this.percentageValue(value.n)));
        }
        div(value) {
            if (value.TYPE === DATATYPE.PERCENTAGE) {
                return Percentage.New(this.n.div(value.n));
            }
            if (value.lf) {
                return Percentage.New(value.n.div(this.percentageValue(value.n)));
            }
            return Percentage.New(this.percentageValue(value.n).div(value.n));
        }
        pow(value) {
            if (value.TYPE === DATATYPE.PERCENTAGE) {
                return Percentage.New(this.n.pow(value.n));
            }
            if (value.lf) {
                return Percentage.New(value.n.pow(this.percentageValue(value.n)));
            }
            return Percentage.New(this.percentageValue(value.n).pow(value.n));
        }
        mod(value) {
            if (value.TYPE === DATATYPE.PERCENTAGE) {
                return Percentage.New(this.n.mod(value.n));
            }
            if (value.lf) {
                return Percentage.New(value.n.mod(this.percentageValue(value.n)));
            }
            return Percentage.New(this.percentageValue(value.n).mod(value.n));
        }
        percentageValue(value) {
            return value.mul(this.n.div(Percentage.base));
        }
        print() {
            return `% ${this.toNumericString()}`;
        }
        New(value) {
            return Percentage.New(value);
        }
    }
    Percentage.base = new decimal_js_1.Decimal(100);
    Type.Percentage = Percentage;
    /**
     * Number with unit
     */
    class UnitNumber extends Numeric {
        constructor(value, unit) {
            super(value);
            this.unit = unit;
            this.TYPE = DATATYPE.UNIT;
            this.TYPE_RANK = TYPE_RANK.UNIT;
        }
        static New(value, unit) {
            return new UnitNumber(value, unit);
        }
        static convertToUnit(value, unit) {
            if (value instanceof UnitNumber) {
                const value2 = value;
                if (value2.unit.id === unit.id && value2.unit.unitType !== unit.unitType) {
                    return UnitNumber.New(value2.convert(unit.ratio, unit.bias), unit).setSystem(value.ns);
                }
            }
            return UnitNumber.New(value.n, unit).setSystem(value.ns);
        }
        New(value) {
            return new UnitNumber(value, this.unit);
        }
        isZero() {
            return this.n.isZero();
        }
        isNegative() {
            return this.n.isNegative();
        }
        negated() {
            return this.New(this.n.negated());
        }
        gt(value) {
            let left;
            let right;
            [left, right] = this.lf ? [this, value] : [value, this];
            if (value instanceof UnitNumber) {
                const left1 = left;
                const right1 = right;
                if (left1.unit.id === right1.unit.id) {
                    return new FcalBoolean(left1.convert(right1.ratio(), right1.bias()).gt(right1.n));
                }
            }
            return new FcalBoolean(left.n.gt(right.n));
        }
        gte(value) {
            let left;
            let right;
            [left, right] = this.lf ? [this, value] : [value, this];
            if (value instanceof UnitNumber) {
                const left1 = left;
                const right1 = right;
                if (left1.unit.id === right1.unit.id) {
                    return new FcalBoolean(left1.convert(right1.ratio(), right1.bias()).gte(right1.n));
                }
            }
            return new FcalBoolean(left.n.gte(right.n));
        }
        lt(value) {
            let left;
            let right;
            [left, right] = this.lf ? [this, value] : [value, this];
            if (value instanceof UnitNumber) {
                const left1 = left;
                const right1 = right;
                if (left1.unit.id === right1.unit.id) {
                    return new FcalBoolean(left1.convert(right1.ratio(), right1.bias()).lt(right1.n));
                }
            }
            return new FcalBoolean(left.n.lt(right.n));
        }
        lte(value) {
            let left;
            let right;
            [left, right] = this.lf ? [this, value] : [value, this];
            if (value instanceof UnitNumber) {
                const left1 = left;
                const right1 = right;
                if (left1.unit.id === right1.unit.id) {
                    return new FcalBoolean(left1.convert(right1.ratio(), right1.bias()).lte(right1.n));
                }
            }
            return new FcalBoolean(left.n.lte(right.n));
        }
        eq(value) {
            let left;
            let right;
            [left, right] = this.lf ? [this, value] : [value, this];
            if (value instanceof UnitNumber) {
                const left1 = left;
                const right1 = right;
                if (left1.unit.id === right1.unit.id) {
                    return new FcalBoolean(left1.convert(right1.ratio(), right1.bias()).eq(right1.n));
                }
            }
            return new FcalBoolean(left.n.eq(right.n));
        }
        nEq(value) {
            return this.eq(value).not();
        }
        plus(value) {
            if (value instanceof UnitNumber) {
                const right = value;
                if (this.unit.id === value.unit.id) {
                    return right.New(this.convert(right.ratio(), right.bias()).add(right.n));
                }
                return value.New(this.n.plus(value.n));
            }
            return this.New(this.n.plus(value.n));
        }
        mul(value) {
            if (value instanceof UnitNumber) {
                const right = value;
                if (this.unit.id === value.unit.id) {
                    return right.New(this.convert(right.ratio(), right.bias()).mul(right.n));
                }
                return value.New(this.n.mul(value.n));
            }
            return this.New(this.n.mul(value.n));
        }
        div(value) {
            let left;
            let right;
            [left, right] = this.lf ? [this, value] : [value, this];
            if (value instanceof UnitNumber) {
                const left1 = left;
                const right1 = right;
                if (left1.unit.unitType === right1.unit.unitType) {
                    return new Type.BNumber(left1.n.div(right1.n));
                }
                if (left1.unit.id !== right1.unit.id) {
                    return left1.New(left1.n.div(right.n));
                }
                return new Type.BNumber(left1.n.div(right1.convert(left1.ratio(), left1.bias())));
            }
            return this.New(left.n.div(right.n));
        }
        pow(value) {
            let left;
            let right;
            [left, right] = this.lf ? [this, value] : [value, this];
            if (value instanceof UnitNumber) {
                const left1 = left;
                const right1 = right;
                if (left1.unit.unitType === right1.unit.unitType) {
                    return left1.New(left1.n.pow(right1.n));
                }
                if (left1.unit.id !== right1.unit.id) {
                    return left1.New(left1.n.pow(right.n));
                }
                return left1.New(left1.n.pow(right1.convert(left1.ratio(), left1.bias())));
            }
            return this.New(left.n.pow(right.n));
        }
        mod(value) {
            let left;
            let right;
            [left, right] = this.lf ? [this, value] : [value, this];
            if (value instanceof UnitNumber) {
                const left1 = left;
                const right1 = right;
                if (left1.unit.id !== right1.unit.id) {
                    return left1.New(left1.n.mod(right1.n));
                }
                if (left1.unit.unitType === right1.unit.unitType) {
                    return left1.New(left1.n.mod(right1.n));
                }
                return left1.New(left1.n.mod(right1.convert(left1.ratio(), left1.bias())));
            }
            return this.New(left.n.mod(right.n));
        }
        convert(ratio, bias) {
            return this.n
                .mul(this.ratio())
                .add(this.bias())
                .minus(bias)
                .div(ratio);
        }
        ratio() {
            return this.unit.ratio;
        }
        bias() {
            return this.unit.bias;
        }
        print() {
            if (this.n.lessThanOrEqualTo(1) && !this.n.isNegative()) {
                return `${this.toNumericString()} ${this.unit.singular}`;
            }
            return `${this.toNumericString()} ${this.unit.plural}`;
        }
    }
    Type.UnitNumber = UnitNumber;
    class FcalBoolean extends BNumber {
        constructor(value) {
            if (typeof value === 'boolean') {
                super(value ? 1 : 0);
                this.v = value;
                return;
            }
            super(value);
            this.v = !this.n.isZero();
        }
        print() {
            return this.v + '';
        }
        not() {
            return this.v ? FcalBoolean.FALSE : FcalBoolean.TRUE;
        }
    }
    FcalBoolean.TRUE = new FcalBoolean(1);
    FcalBoolean.FALSE = new FcalBoolean(0);
    Type.FcalBoolean = FcalBoolean;
})(Type || (Type = {}));
exports.Type = Type;
